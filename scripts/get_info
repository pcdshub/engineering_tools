#!/reg/g/psdm/sw/conda/inst/miniconda2-prod-rhel7/envs/ana-1.5.19/bin/python
import argparse
import socket
import os
import sys
import requests
import logging
import json

parser = argparse.ArgumentParser()
parser.add_argument("--run", help="get last run", action='store_true')
parser.add_argument("--exp", help="get experiment name", action='store_true')
parser.add_argument('--expmeta', help='get all associated experiment metadat', action='store_true')
parser.add_argument("--live", help="ongoing?", action='store_true')
parser.add_argument("--ended", help="ended", action='store_true')
parser.add_argument("--hutch", help="hutch to get info for {xxx}")
parser.add_argument("--station", help="optional station for hutch with two daqs, e.g. cxi and mfx")
parser.add_argument("--getHutch", help="get hutch (uppercase)", action='store_true')
parser.add_argument("--gethutch", help="get hutch (lowercase)", action='store_true')
parser.add_argument("--getstation", help="get hutch station (for multiple daqs)", action='store_true')
parser.add_argument("--getbase", help="get base daq name (hutch_station if multiple daqs, otherwise hutch)", action='store_true')
parser.add_argument("--getinstrument", help="get instrument (HUTCH_station if multiple daqs, otherwise hutch)", action='store_true')
parser.add_argument("--getcnf", help="get cnf file name)", action='store_true')
parser.add_argument("--files_for_run", help="get xtc files for run")
parser.add_argument("--nfiles_for_run", help="get xtc files for run")
parser.add_argument("--setExp", help="set experiment name")
args = parser.parse_args()

ws_url = "https://pswww.slac.stanford.edu/ws/lgbk"
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

ACTIVE_EXP_URL = '/lgbk/ws/activeexperiment_for_instrument_station'

LCLS2_HUTCHES = [
    'tmo',
    'txi',
    'rix'
] 

LCLS_HUTCHES = [
    'xpp',
    'xcs',
    'mfx',
    'cxi',
    'mec', 
    'det', 
    'lfe',
    'kfe',
    'tst'
]
#foundHutch=False
#hutch=''

#populate hutch-specific subnets here:
HUTCH_SUBNETS = {
    'tmo': ['28','132','133','134','135'],
    'txi': ['29','136','137','138','139'],
    'rix': ['31','144','145','146','147'],
    'xpp': ['22','84','85','86','87'],
    'xcs': ['25','80','81','82','83'],
    'cxi': ['26','68','69','70','71'],
    'mfx': ['24','72','73','74','75'],
    'mec': ['27','76','77','78','79'],
    'det': ['58', '59'],
    'lfe': ['88','89','90','91'],
    'kfe': ['92','93','94','95'],
    'tst': ['23','148','149','150','151']
}


if args.hutch:
    # Check if the hutch arg upper/lower is in lcls or lcls2 hutches
    hutch = args.hutch
    hutch_set = set([hutch.upper(), hutch.lower()])
    if bool(hutch_set.intersection(LCLS_HUTCHES)):
        hutch = hutch.upper()
    elif bool(hutch_set.intersection(LCLS2_HUTCHES)):
        hutch = hutch.lower()
    else:
        print('unknown hutch {0}'.format(hutch))
        sys.exit()
else:
    hutch = ''
    # Get hutch from hostname string
    hostname = socket.gethostname()
    match_hostname_lcls = [hutch for hutch in LCLS_HUTCHES if hutch in hostname]
    match_hostname_lcls2 = [hutch for hutch in LCLS2_HUTCHES if hutch in hostname]
    
    # Get hutch from subnet key
    ip = socket.gethostbyname(hostname)
    subnet = ip.split('.')[2]
    subnet_key = [k for k, v in HUTCH_SUBNETS.items() if subnet in v]

    # Get hutch from path
    path = os.getcwd()
    lcls_path_key = [hutch for hutch in LCLS_HUTCHES if hutch in path]
    lcls2_path_key = [hutch for hutch in LCLS2_HUTCHES if hutch in path]

    # Run through all conditions to see if we can find hutch name
    if subnet_key:
        hutch = subnet_key.pop()
        if hutch in LCLS_HUTCHES:
            hutch = hutch.upper()
        elif hutch in LCLS2_HUTCHES:
            hutch = hutch.lower()
    # Check hutch from host name
    elif match_hostname_lcls:
        hutch = match_hostname_lcls.pop().upper()
    elif match_hostname_lcls2:
        hutch = match_hostname_lcls2.pop().lower()
    # Check psusr accounts
    elif 'psusr' in hostname:
        if hostname.find('psusr13')>=0:
            hutch='XPP'
        elif hostname.find('psusr21')>=0:
            hutch='XCS'
        elif hostname.find('psusr22')>=0:
            hutch='CXI'
        elif hostname.find('psusr23')>=0:
            hutch='MEC'
        elif hostname.find('psusr24')>=0:
            hutch='MFX'
    # Check for hutch on the path
    elif lcls_path_key:
        hutch = lcls_path_key.pop().upper()
    elif lcls2_path_key:
        hutch = lcls2_path_key.pop().lower()
    # Not touching this one, I like the greater than -1 because -1 + -1 = -2.
    # This is becoming quite enjoyable
    elif not hutch and path.find('xrt')+hostname.find('xrt')>=-1 or path.find('xtod')+hostname.find('xtod')>=-1:
        hutch='LFE' #because we have so many names for the same subnet.
    else:
        #then ask.....outside of python
        print 'Could not locate hutch this is run from'
        sys.exit()

if args.getHutch:
    print hutch.upper()
if args.gethutch:
    print hutch.lower()

# cxi is such a rebel
if hutch.lower() in ['cxi']:
    nstations = 2
    if args.station is not None:
        station = int(args.station)
    else:
        hostname=socket.gethostname()
        if 'monitor' in hostname:
            station = 1
        else:
            station = 0
    daq_base = '{:}_{:}'.format(hutch.lower(),station)
    instrument = '{:}:{:}'.format(hutch.upper(),station)
else:
    # This might need to change as well, no daq yet
    daq_base = hutch.lower()
    instrument = hutch.upper()
    nstations = 1
    if args.station:
        station = int(args.station)
    else:
        station=0

if station >= nstations:
    print "Invalid --station={:} keyword set for hutch {:}".format(hutch)
    sys.exit()

if args.getstation:
    print station
elif args.getinstrument:
    print instrument
elif args.getbase:
    print daq_base
elif args.getcnf:
    print daq_base+'.cnf'

request_args = {"instrument_name": hutch, "station": station}
exp_metadata = requests.get(''.join([ws_url, ACTIVE_EXP_URL]), request_args).json()
exp = exp_metadata.get('value', {}).get('name')

# I don't think we'll want to parse this
# in bash, but useful quick lookup
if args.expmeta:
    print(json.dumps(exp_metadata, sort_keys=True, indent=2))

# This should be active experiment since we can pass in an experiment name
if args.exp:
    print(exp)

# If the user wants to know about some other experiment
# we'll do the rest of the logic with that name
if args.setExp:
    exp = args.setExp

# Rest of logic is run/exp name specific, no need for hutch info anymore
# This could be a different script that is just experiment lookup
rundoc = requests.get(''.join([ws_url, '/lgbk/', exp, '/ws/current_run'])).json()['value']

if args.run:
    if not rundoc:
        print('no runs started yet, exiting')
        sys.exit()
    if args.ended:
        if rundoc.get('end_time', None):
            print(int(rundoc['num']))
        else:
            print(int(rundoc['num'] - 1)) 
            # I'm a big fan of comments like these ;)
            # Really bogus way to determine this; but copying over from previous code.
    else:
        print(int(rundoc['num']))
        if args.live:
            if not rundoc.get('end_time', None):
                print('live')
            else:
                print('ended')

if args.files_for_run or args.nfiles_for_run:
    if not rundoc:
        print('no runs started yet, exiting')
        sys.exit()
    if args.files_for_run:
        run = int(args.files_for_run)
    if args.nfiles_for_run:
        run = int(args.nfiles_for_run)

    runLast = int(rundoc['num'])
    if run > runLast:
        print('run %s not taken yet, last run is %s'%(run,runLast))
    else:
        file_list = requests.get(ws_url + "/lgbk/" + exp + "/ws/" + str(run) + "/files_for_live_mode").json()["value"]
        if args.files_for_run:
            for tfile in file_list:
                print('/reg/d/psdm/'+tfile)
        elif args.nfiles_for_run:
            #look at files, remove stream 80, only first chunk, return number.
            nFiles=0
            for tfile in file_list:
                tfilename = '/reg/d/psdm/'+tfile
                if tfilename.find('c00')>=0 and tfilename.find('-s8')<0:
                    nFiles=nFiles+1
            print('%d %d'%(nFiles,len(file_list)))
