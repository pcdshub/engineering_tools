#!/bin/bash

usage() 
{
cat << EOF

/reg/g/pcds/engineering_tools/latest/scripts/evrStatus : Displays a GUI for the EVRs of the selected area.
                                                         Running without arguments results in prompt and allows for user input.

Syntax: $0 \

        [ < area > <area> .. ]
        [ -h ] [ -Help ]
        [ -l ]
        [ -pv ] [ <EVR PV Name> <EVR PV Name>.. ]
        [ -pvs ] [  --< area >  --< area > ..  ]  
        
Supported Arguments:
   -h, -Help: Display this help text
   -l: List available areas
   -pv: Allow EVR PVs to be entered by the user as command line arguments or be prompted.
   -pvs --< area >: Display the EVR PVs for a requested Area that are built into this script.
    
EOF
}

# evrList
# all new PV entries need to be follwed by a comma,
evrs=(
CXI:R48:EVR:41,
CXI:R24:EVR:18,
CXI:R57:EVR:21,
CXI:IPM:EVR,
CXI:REC:EVR:04,
CXI:DG2:BMMON:EVR,
EVR:FEE:KMONO:DAQ,
EVR:FEE:GASDET:DAQ,
EVR:LAS:LHN:01,
EVR:LAS:LHN:04,
EVR:LAS:02,
EVR:LAS:01,
LAS:MEC:EVR:01,
LAS:MEC:EVR:02,
LAS:MEC:EVR:03,
EVR:MEC:USR01,
MEC:TC1:EVR:01,
EVR:MEC:REC01,
MEC:XT2-1:BMMON:EVR,
MFX:EVR:DIA:P6740,
MFX:EVR:DG2:P6740,
MFX:REC:EVR:02,
MFX:DG1:BMMON:EVR,
IM3K4:PPM:CAM:EVR,
TMO:MISC:EVR:01,
TST:EVR:REC02,
XCS:LAS:EVR:01,
XCS:R42:EVR:01,
XCS:R44:EVR:44,
XCS:SND:DIO:EVR,
EVR:XCS:USDUSB4:01,
XCS:SB2:BMMON:EVR,
XPP:R32:EVR:32,
XPP:IPM:EVR,
XPP:R30:EVR:28,
XPP:R30:EVR:26,
XPP:USR:EVR,
XPP:SB2:BMMON:EVR,
CXI:R48:EVR:41,
XRT:EVR:MISC02,
XRT:R32:EVR:41,
XRT:R38:EVR:44,
XRT:R04:EVR:33,
XRT:R44:EVR:38,
HFX:DG2:BMMON:EVR,
)

# Areas to search
areas=(
"MEC"
"CXI"
"MFX"
"XCS"
"XRT"
"XPP"
"TMO"
"FEE"
"LAS"
"DET"
"RIX"
"TST"
"TXI"
"ALL"
)

# Reads user input when there are no command line arguments
read_hutch () {   
    echo "Enter area you'd like to see ie (XPP, TMO, FEE, ALL..etc):" 
    echo "(Press enter to exit this session)"
    read -r  hutch
    hutch=${hutch^^}  # make user input uppercase for user friendliness  

    if [[ "${hutch}" == "" ]]; then 
        exit
    fi
}

# Checks if user inputted area is valid 

in_areas() {
    hutch_in_areas=$(echo "${areas[@]}" | grep -o "$hutch" | wc -w) # 1 or 0 depending if user input returns a match or not

    if ! [ "$hutch_in_areas" -eq 1 ];then 
        echo "The area you searched:" "$hutch" " does not correspond to any currently in the NEH or FEH where EVRs are located... the list of available areas is:"
        printf "\n"
        printf '%s\n' "${areas[@]}"
        printf "\n"
        echo "Try again: evrStatus <area1> <area2> <area3> ..."
        echo "To see the full list of command line inputs: evrStatus -h"
       exit
    fi
}

# Creates array of requested evr PVs to see the status of

req_evrs_func() {
    req_evrs=()
    if [[ "$hutch" == "ALL" ]]; then  # all callable pvs are requested evr pvs 
        for i in "${evrs[@]}"; do
            req_evrs+=("$i")
        done
    else
        for i in "${evrs[@]}"; do # call only pvs that are associated with specified hutch
            if [[ $i == *"$hutch"* ]]; then
	        req_evrs+=("$i")
	    fi
        done
    fi
    if [[ "$hutch" == "TMO" ]]; then
        req_evrs+=("IM3K4:PPM:CAM:EVR,")       # This PV needs to be added manually b/c the name does not have "$hutch" identifier in it

    elif [[ "$hutch" == "XRT" ]]; then
	req_evrs+=("HFX:DG2:BMMON:EVR,")       # This PV needs to be added manually b/c the name does not have "$hutch" identifier in it
    fi
    export req_evrs
}

# Transforms array of requested PVs into an array of strings which is readable by the Extensible Display Manager
to_display () {
    local evr_num=${#req_evrs[@]} # counter for discerning which screen file to display

    for ((i=0; i< 10; i++)); do  # assign EVR00=<HUTCH:EVR:PV0>, EVR01=<HUTCH:EVR:PV1>...
         local macro_array+="EVR0$i=${req_evrs[$i]}"  # array containing macro assignments 
    done

    if [[ evr_num -ge 10 ]]; then
        for ((j=10; j < ${#req_evrs[@]}; j++ )); do
            macro_array+="EVR$j=${req_evrs[$j]}"
        done
    fi
    local macros_exported=${macro_array[*]} # macros are exported to edm as a string
    export macros_exported evr_num

    echo "Displaying EVR status screen for " "$hutch" "..."    
    printf "\n"           
    
    /reg/g/pcds/epics-dev/screens/edm/common/current/evrStatus/edm-evrs.cmd
}

# Begin Command line argument handling:

command_args=$*
command_args_string="$*"

# Argument to display the PVs of a requested area

pvs_areas=()
for i in "${areas[@]}"; do pvs_areas+=("--$i"); done

# Other types of command line arguments:

pv_args=()
opt_args=()
opts_available=("-L" "-PV" "-PVS" "${pvs_areas[@]}" "-H" "--H" "--HELP" "-Help" "Help")
area_args=()
except_args=()

# Command line args classification logic:

for i in $command_args_string; do
    i=${i^^}
    if [[ "$i" =~ ":" && ${#i} -gt 10 ]]; then
        pv_args+=("$i")
    elif [[ "${areas[*]}" =~ $i ]]; then   # Initial classification filtering
        for j in "${areas[@]}"; do           
            if [[ "$j" == "$i" ]]; then      # Exact Match Filtering
                area_args+=("$i")
            fi
        done
    elif [[ "${opts_available[*]}" =~ $i ]]; then  # Initial classification filtering
	for j in "${opts_available[@]}"; do            
	    if [[ "$j" == "$i" ]];then                 # Exact Match Filtering
                opt_args+=("$i")
            fi
        done
    elif [[ "${#i}" -eq  1 ]]; then 
        except_args+=("$i")
    else
        except_args+=("$i")
    fi
done

# Argument Handling Functions:

# pv_args Handling Function: allow the user to manually enter EVR PVs to see the status of either on the command line
args_pv_handling() { 
    evr_num=0
    for i in "${pv_args[@]}"; do
        local macro_array+="EVR0$evr_num=$i,"
        evr_num=$((evr_num + 1))
    done

    local macros_exported=${macro_array[*]}
    export macros_exported evr_num
    
    /reg/g/pcds/epics-dev/screens/edm/common/current/evrStatus/edm-evrs.cmd
}

# allow the user to manually enter EVR PVs to see the status when propmpted

manual_pv_entry() { 
    local evr_num=0
    echo "Enter the EVR PV(s) you would like to see the display status of. Please only enter one per line:" 
    echo "(Press Return to exit this dialog)"
    read -r input
    if [[ "$input" == "" ]]; then
        exit
    else
        local macro_array+="EVR0$evr_num=$input,"
        evr_num=$((evr_num + 1))
    fi
    while read -r line; do
        if [[ "$line" == "" ]]; then
            break
        else
            local macro_array+="EVR0$evr_num=$line,"
            evr_num=$((evr_num + 1))
        fi
    done 
                                                                                
    local macros_exported=${macro_array[*]}
    export macros_exported evr_num

    /reg/g/pcds/epics-dev/screens/edm/common/current/evrStatus/edm-evrs.cmd
}

except_handling() {
    for i in "${except_args[@]}"; do

# 1: Wrong type of PV format  
        if [[ "$i" =~ ":" && ${#i} -lt 10 ]]; then
            echo "There seems to be a typo in your requested PV: " "$i" 
            echo "Please try again"

# 2: Wrong type of area format --> error handling is already executed in the in_areas function

# 3: Option non-existant
        elif ! [[ "${opts_available[*]}" =~ $i ]]; then
            echo "Invalid Argument: " "$i"
            printf "The list of supported command line arguments are: \n <area> \n -PV \n -l \n -h \n --help \n -PVS -<area> \n"
            printf "\n"
	    echo "For full documentation: $ evrStatus -h "
	elif [[ "${#i}" -eq 1 ]]; then
            echo "Invalid Argument: " "$i"
            printf "The list of supported command line arguments are: \n <area> \n -PV \n -l \n -h \n --help \n -PVS -<area> \n"
            printf "\n"
            echo "For full documentation: $ evrStatus -h "


        fi
    done
}

# Status Screen Display Handling Logic:

if [[ "$1" == "" ]]; then
    read_hutch #execute user input function first
    in_areas # test if user input is in accepted list
    req_evrs_func 
    to_display
fi
if [[ "${opt_args[*]}" == *"-L"* ]]; then
    echo "The areas available to see EVR status are:"
    printf '%s\n' "${areas[@]}"
    printf "\n"
fi
if [[ "${opt_args[*]}" == *"-H" || "$i" == *"HELP" ]]; then
    echo " $( usage ) "
    printf "\n"
fi
if [[ "${opt_args[*]}" == *"-PVS"* ]]; then
    for i in "${opt_args[@]}"; do
        if [[ "${pvs_areas[*]}" =~ $i ]];then
            hutch=${i:2:4}
            req_evrs_func
            printf "\n"
            echo "Here are the PVs currently loaded into the script for:" "$hutch"
	    printf "\n"
            for j in "${req_evrs[@]}"; do echo "$j"; done
            printf "\n"
        elif [[ "${opt_args[*]}" == "-PVS" && ${#opt_args[@]} -eq 1 ]]; then
	    read_hutch
            in_areas
            printf "\n"
            req_evrs_func 
            echo "Here are the PVs currently loaded into the script for:" "$hutch"
	    for j in "${req_evrs[@]}"; do echo "$j"; done
            printf "\n" 
	fi
    done
fi
if [[ ${#area_args[@]} -ne 0 ]]; then
   for i in "${area_args[@]}"; do
       hutch=$i
       in_areas
       req_evrs_func
       to_display
   done
fi
if [[ ${#pv_args[@]} -ne 0 ]]; then
   args_pv_handling
elif [[ "${opt_args[*]}" == *"-PV"* && ${#pv_args[@]} -eq 0 ]]; then
   manual_pv_entry
fi
if [[ ${#except_args[@]} -ne 0 ]]; then
    except_handling
fi
